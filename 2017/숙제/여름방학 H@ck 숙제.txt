1. pcap 라이브러리를 이용해서 패킷캡쳐 후 내용 출력하기 (C or C++) 구조체 부분 직접 작성 필요 코드리뷰 예정
2. CPU 구조 살펴보고 보고서 써오기
3. 디지털 논리 회로 예습하기
4. x86 레지스터 종류 및 역할 확실하게 알아오기




1. pcap 라이브러리를 이용해서 패킷캡쳐 후 내용 출력하기 (C or C++) 구조체 부분 직접 작성 필요 코드리뷰 예정
    가. Libpcap
        1) 의미
            Libpcap(이하 pcap)은 "Portable Packet Capturing Library"의 줄임말이며, 말그대로 "간단하게 패킷을 캡쳐하기 위한 라이브러리" 이다.
            pcap 외에도 패킷캡쳐를 위한 도구들이 있으나 대부분의 경우 운영체제에 종속적이여서, 운영체제별로 코드를 다시 짜야 한다는 불편함이 있다. 대표적인 도구로는 SOCK_PACKET, LSF, SNOOP, SNIT 등이 있다.
            이에 비해 pcap는 운영체제에 상관없이 범용적으로 사용가능한 API를 제공해주므로, 공용프로그램 혹은 공용라이브러리의 제작이 가능하도록 도와준다. 또한 간단하게 사용가능한 사용자 레벨 라이브러리이다.
            libpcap 를 이용한 가장 대표적인 프로그램이 tcpdump 와 SAINT 와 같은 프로그램들이다.
        2) 설치
            Unix 계열 운영체제를 사용하고 있다면, 대부분 tcpdump를 곧바로 사용할 수 있다. tcpdump를 사용할 수 있다는 것은 그 기반이 되는 libpcap 역시 설치되어 있다는 말이다.
            그러나 만약 설치가 되어 있지 않다면 tcpdump.org에서 받아서 컴파일 후 설치할 수 있다.
            레드헷이나 데비안 계열의 리눅스 사용자라면 해당 패키지를 배포하는 ftp 사이트에서 다운로드 후 설치할 수 있다. 솔라리스 운영체제의 경우 www.sunfreeware.com에서 패키지를 다운로드 받아서 설치할 수 있다.
        3) API
            가) int pcap_lookupnet(char *device, bpf_u_int32 *netp, bpf_u_int32 *maskp, char *errbuf)
				네트웍 디바이스에 대한 네트웍 및 mask 번호를 되돌려준다. 네트웍 번호는 netp에 mask 번호는 maskp에 저장된다. device는 pcap_lookupdev 등을 통해 얻어온 네트웍 디바이스 이름이다.
                에러가 발생할경우 -1이 리턴되며, 에러 내용이 errbuf에 저장된다.
            나) char *pcap_lookupdev(char *errbuf)
                네트웍 디바이스를 가져오는 함수이다. 가능한 다비이스중 가장 번호가 낮은 디바이스를 가져온다. 리눅스라면 eth0인 경우가 많다. 다른 디바이스를 통해 패킷을 캡쳐하려면 이 함수를 사용하지 않고 프로그램의 입력으로 디바이스명을 가져오면 된다.
            다) pcap_t *pcap_open_live(const char *device, int snaplen, int promisc, int to_ms, char *errbuf)
                실제 기기를 열어주는 기능을 한다. snaplen는 패킷당 저장할 바이트 수를 의미한다. promisc은 패킷캡쳐 모드를 의미한다. promisc에 지정될 수 있는 상수 중 하나인 PROMISCUOUS는 수 1이며 네트웍 디바이스에 오는 모든 패킷을 받겠다는 의미이다. 패킷은 버퍼로 전달될 때 바로 전달되는 것이 아니라 세 번째 인자로 전달한 시간을 넘겼을 때나 버퍼가 다 채워졌을 때 응용프로그램으로 전달된다.
            라) int pcap_compile(pcap_t *p, struct bpf_program *fp, const char *str, int optimize, bpf_u_int32 netmask)
                정해진 필터룰에 의해 필터 프로그램을 컴파일하게 되는데 우리가 원하는 패킷은 필터룰을 주어야만 원하는 패킷만을 얻을 수 있습니다. 실제 tcpdump에서 사용하는 필터룰이 여기에서 쓰입니다. 예를 들면 "tcp port 80" 입니다.

2. CPU 구조 살펴보고 보고서 써오기
    가. 레지스터(Register)
        1) 의미
            연산유닛과 연결된 액세스속도가 가장 빠른 기억장치이다.
    나. 프로그램 카운터(Program Counter)
        1) 의미
            다음에 인출할 명령어의 주소를 가지고 있는 레지스터, 각 명령어가 인출된 후에는 명령어 길이만큼 주소를 증가시킴으로써 주소를 포인팅한다. 분기(jump) 명령어가 실행되는 경우에는 목적지주소로 갱신한다.
    다. 명령어 레지스터(Instruction Register)
        1) 의미
            현재 실행중인 명령의 내용을 기억하고 있는 레지스터이다.
    라. 산술논리연산장치(Arithmetic Logic Unit)
        1) 의미
            각종 산술연산(덧셈, 뺄셈, 곱셈, 나눗셈)과 논리연산(AND, OR, NOT, XOR 등)들을 수행하는 회로들로 이루어진 회로이다.
    마. 제어부(Control Unit)
        1) 의미
            명령어를 해석하고, 그것을 실행하기 위한 제어 신호들(control signals)을 순차적으로 발생하는 회로이다.
    바. 어드레싱 유닛(Addressing Unit)
        1) 의미
            CPU가 메모리 혹은 데이터를 읽거나 쓸 때, 메모리 입출력 어드레스를 만들어주는 유닛이다.
    사. 버스(Bus)
        1) 의미
            데이터 버스를 통해 데이터를 메모리에 읽거나 쓴다. 버스 유닛에서 데이터를 읽어 들였을 경우 그 데이터가 레지스터에 저장되나 버스 유닛이 명령어를 읽어들였을 경우 명령어가 프리패치(Prefetch)큐(Que)에 저장된다.
    아. 캐시(Cache)
        1) 의미
            CPU의 동작 속도가 급격하게 빨라지면서 CPU는 엄청나게 빠른 속도로 동작 하게 되었다. 그러면서 주기억장치(RAM)과 주변장치들의 데이터 전송에서 높낮음이 발생을 하였고 이에 따라 병목현상이 발생하였다.
            CPU와 RAM의 속도에 많은 차이가 나다 보니 CPU와 RAM사이에 고속의 메모리(SRAM)을 두어, 데이터를 자주 읽는 것은 임시로 데이터를 저장함으로서 작업의 속도를 높일수 있었다. 이러한 고속 메모리를 캐시(Cache)라고 한다.

3. 디지털 논리 회로 예습하기
    가. 의미
        전자공학에서 논리 회로는 불 대수를 물리적 장치에 구현한 것으로, 하나 이상의 논리적 입력값에 대해 논리 연산을 수행하여 하나의 논리적 출력값을 얻는 전자회로를 말한다. AND, OR, NOT의 기본 불 대수를 수행하며, 이 기본 불 대수들의 결합으로 복합적인 논리 기능을 수행한다.
    나. 조합 회로
        1) 의미
            입력 신호만으로 출력이 결정되는 회로이다.
        2) 불 대수
                A   B   Y
        1) NOT
                0   -   1
                1   -   0
        2) AND
                0   0   0
                0   1   0
                1   0   0
                1   1   1
        3) OR
                0   0   0
                0   1   1
                1   0   1
                1   1   1
        4) NAND
                0   0   1
                0   1   1
                1   0   1
                1   1   0
        5) NOR
                0   0   1
                0   1   0
                1   0   0
                1   1   0
        6) XOR
                0   0   0
                0   1   1
                1   0   1
                1   1   0
    다. 순차 회로
        1) 의미
            이전 상태의 신호와 외부 입력 신호에 따라 출력이 결정되는 회로이다. 이전상태가 계속 유지되려면 출력을 입력에 반영하는 되먹임 논리회로 구조를 갖는다.
        2) 래치와 플립플롭
            가) 래치
                입력이 들어왔을 때, 조건이 맞은면 바로 반영된다. 단, EN 신호가 있을 경우, 이 조건이 만족해야 한다.
            나) 플립플롭
                입력이 들어왔을 때, 클럭(CLK, CK, clock)의 동기 신호에 의해 입력이 반영된다.
        3) 카운터
            가) 의미
                레지스터와 게이트로 구성되어서 순서에 따라서 일정한 출력이 나오고, 일정한 주기가 되면 원래 상태로 되돌아간다.
            나) 필드 코드 카운터(Filled Code Counter): 모든 출력의 상태가 사용되는 것.
                2 비트 존슨 카운터
                그레이 코드 카운터
                이진 카운터
            다) 언필드 코드 카운터(Unfilled Code Counter): 출력의 일부만 사용되고, 그 밖에는 알 수 없는 상태가 되는 것.
                3 비트 이상의 존슨 카운터
                링 카운터
                M계열 발생기 (LFSR: Linear Feedback Shift Register)
        4) 시퀀서 (Sequencer)
            가) 의미
                입력 신호에 따라서 카운터, 레지스터, 게이트 등으로 제작된 회로가 연산 및 일련의 동작을 하는 것이다.

4. x86 레지스터 종류 및 역할 확실하게 알아오기
    가. 범용
        1) EAX
            곱셈과 나눗셈 명령에서 자동으로 사용되고 함수의 리턴값이 저장되는 용도로 사용된다.
        2) EBX
            ESI나 EDI와 결합하여 인덱스에 사용된다.
        3) ECX
            반복 명령어 사용시 카운터로 사용된다. ECX 레지스터에 반복할 횟수를 지정해놓고 반복 작업을 수행한다.
        4) EDX
            EAX와 같이 쓰이며 부호 확장 명령 등에 쓰인다.
    나. 인덱스
        1) ESI
            데이터 복사나 조작시 Source Data의 주소가 저장된다. ESI 레지스터가 가리키는 주소의 데이터를 EDI 레지스터가 가리키는 주소로 복사하는 용도로 많이 사용된다.
        2) EDI
            복사 작업시 Destination의 주소가 저장된다. 주로 ESI 레지스터가 가리키는 주소의 데이터가 복사된다.
    다. 포인터
        1) EIP
            다음에 실행해야 할 명령어가 존재하는 메모리 주소가 저장된다. 현재 명령어를 실행 완료한 후에 EIP 레지스터에 저장되어 있는 주소에 위치한 명령어를 실행하게 된다. 실행 전 EIP 레지스터는 다음 실행해야 할 명령어가 존재하는 주소의 값이 저장된다.
        2) EBP
            하나의 스택 프레임의 시작 지점 주소가 저장된다. 현재 사용되는 스택 프레임이 소멸되지 않는 동안 EBP의 값은 변하지 않는다. 현재의 스택 프레임이 소멸되면 이전에 사용되던 스택 프레임을 가리키게 된다.
        3) ESP
            하나의 스택 프레임의 끝 지점 주소가 저장된다. PUSH, POP 명령어에 따라서 ESP의 값이 4byte씩 변한다.
    라. 부동 소수점
        1) ST(0), ST(1), ST(2), ST(3), ST(4), ST(5), ST(6), ST(7)
            부동 소수 연산에 사용되는 레지스터
    마. 플래그
        1) Eflag
            가) OF
                Overflow: 산술 연산 후 상위(가장 왼쪽) 비트의 overflow를 나타냄
            나) DF
                Direction: 스트링(문자) 데이터를 이동시키거나 비교할 때 왼쪽 또는 오른쪽의 방향 결정
            다) IF
                Interrupt: 키보드 입력과 같은 외부 인터럽트가 처리되어야 하는지 또는 무시되어야 하는지를 나타낸다.
            라) TF
                Trap: 단일 단계 모드(single-step mode)의 프로세서 연산을 허용한다. 디버거 프로그램은 TF 플래그를 설정해서, 사용자가 한 번에 하나씩 명령어를 실행시키고, 레지스터와 메모리 상에서 그 영향을 조사할 수 있게 한다.
            마) SF
                Sign: 산술 연산의 결과 값에 대한 부호를 나타낸다. (0=양수, 1=음수)
            바) ZF
                Zero: 산술이나 비교 연산의 결과를 나타낸다. (0=결과 값이 0이 아님, 1=결과 값이 0)
            사) AF
                Auxiliary carry: 특수화된 산술에서 사용되며, 그 산술 연산에서 비트 3에서 비트 4로의 캐리를 포함한다.
            아) PF
                Parity: 연산 겨로가 1비트들의 개수를 나타낸다. 그 개수가 짝수인 경우짝수 패리티(even parity)라 부르며, 홀수인 경우 홀수 패리티(odd parity)라 한다.
            자) CF
                Carry: 산술 연산 후 상위 비트의 캐리를 포함한다. 또한 비트 자리이동(shift) 또는 비트 회전(rotate) 연산 후 가장 마지막의 비트 내용을 포함한다.